---
title: "R Notebook"
output: html_notebook
---

###  grDevice Package

* colorRamp()
* colorRampPalette

these functions take colors and help to interpolate between colors

* colors(): lists the names of colors you can use in any plotting function
```{r}
# if you run colors() function, it will return 657 color names.
# colors()
```

Here you take random sample of 10 color names

```{r}
sample(colors(), 10)
```

# colorRamp()

take a palette of colors and return a function that takes values between 0 and 1

```{r}
colorRamp("gray")
```


```{r}
pal <- colorRamp(c("red","blue"))
pal(0)

# below[red green blue] like a spectrum; one end is red, the other end is blue
# so pal(0) is left end.
```

We see a 1 by 3 array with 255 as the first entry and 0 in the other 2. This 3 long vector corresponds to red, green, blue (RGB) color encoding commonly used in televisions and monitors. In R, 24 bits are used to represent colors. Think of these 24 bits as 3 sets of 8 bits, each of which represents an intensity for one of the colors red, green, and blue.

The 255 returned from the pal(0) call corresponds to the largest possible number
represented with 8 bits, so the vector (255,0,0) contains only red (no green or blue), and moreover, it's the highest possible value of red.

```{r}
pal(1)
```

```{r}
seq(0, 1, len =6)
```

```{r}
pal(seq(0, 1, len =6))
```

So pal creates colors using the palette we specified when we called colorRamp. In this example none of pal's outputs will ever contain green since it wasn't in our initial palette.

The argument you pass to the returned function specifies the number of colors you want returned. Each element of the returned vector is a 24 bit number, represented as 6 hexadecimal characters, which range from 0 to F. This set of 6 hex characters represents the intensities of red, green, and blue, 2 characters for each color.

# ColorRampPalette() function

take a palette of colors and return a function that takes integer arguments

```{r}
p1 <- colorRampPalette(c("red", "blue"))

p1(2)
```

 We see a 2-long vector is returned. The first entry FF0000 represents red. The FF is hexadecimal for 255, the same value returned by our call pal(0). The second entry 0000FF represents blue, also with intensity 255.
```{r}
p1(6)

# left end is red, other end is blue. Others are interpolation
```
 
 Now we get the 6-long vector (FF0000, CC0033, 990066, 650099, 3200CC, 0000FF). We see the two ends (FF0000 and 0000FF) are consistent with the colors red and blue. How about CC0033? Type 0xcc or 0xCC at the command line to see the decimal equivalent of this hex number. You must include the 0 before the x to specify that you're entering a hexadecimal number.
 
```{r}
0xcc
```
 
 
 So 0xCC equals 204 and we can easily convert hex 33 to decimal, as in 0x33=3*16+3=51. These were exactly the numbers we got in the second row returned from our call to pal(seq(0,1,len=6)). We see that 4 of the 6 numbers agree with our earlier call to pal. Two of the 6 differ slightly.


```{r}
p2 <- colorRampPalette(c("red", "yellow"))

p2(2)
```


```{r}
p2(10)
```
So we see the 10-long vector. For each element, the red component is fixed at FF, and the green component grows from 00 (at the first element) to FF (at the last).


```{r}
p3 <- colorRampPalette(c("blue", "green"), alpha = .5)

p3(5)
```


So what is alpha? Alpha represents an opacity level, that is, how transparent should the colors be. We can add color transparency with the alpha parameter to calls to rgb. We haven't seen any examples of this yet, but we will now.

## RGB function

returns a string to be used in functions.

We see that rgb is a color specification function that can be used to produce any color with red, green, blue proportions. We see the maxColorValue is 1 by default, so if we called rgb with values for red, green and blue, we would specify numbers at most 1 (assuming we didn't change the default for maxColorValue). According to the documentation, what is the maximum number of arguments rgb can have?


```{r}
rgb
```

We see that in the 5-long vector that the call returned, each element has 32 bits, 4 groups of 8 bits each. The last 8 bits represent the value of alpha. Since it was NOT ZERO in the call to colorRampPalette, it gets the maximum FF value. (The same result would happen if alpha had been set to TRUE.) When it was 0 or FALSE (as in previous calls to colorRampPalette) it was given the value 00 and wasn't shown. The leftmost 24 bits of each element are the same RGB encoding we previously saw.

```{r}
x = rnorm(2000, mean = 2, sd = 1)
y = rnorm(2000, mean = 2, sd = 1)
plot(x, y, pch = 19)
```
You can see high density and hard to differentiate because points are overlapping

```{r}
#rgb 
plot(x,y,pch=19,col=rgb(red=0, green=.5, blue=.8, alpha = .3))
```

Which of the following is an R package that provides color palettes for sequential, categorical, and diverging data? RColorBrewer: 

* sequential: from white to dark colors 
* categorical: different color for each categories
* diverging: from color to color but white in the middle

# RcolorBrewer and colorRampalette

```{r}
library(RColorBrewer)

cols <- brewer.pal(3, "BuGn")
cols
```
```{r}
pal <- colorRampPalette(cols)
pal(20)
```
```{r}
image(volcano, col=pal(20))
```

# The smoothScatter() function

smoothScatter produces a smoothed color density representation of a scatterplot, obtained through a (2D) kernel density estimate.

```{r}
x <- rnorm(10000)
y <- rnorm(10000)
smoothScatter(x, y)
```















 



