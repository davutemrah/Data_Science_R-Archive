---
title: "R Notebook"
output: html_notebook
---

### Fixing Character vectors

tolower()
toupper()

```{r}
if(!file.exists("./data")){dir.create("./data")}

fileurl = "https://data.baltimorecity.gov/api/views/dz54-2aru/rows.csv?accessType=DOWNLOAD"

download.file(url = fileurl, destfile = "./data/cameras.csv", method = "curl")

cameradata <- read.csv("./data/cameras.csv")
names(cameradata)
```

```{r}
acs <- read.csv("./data/acs2006housing.csv")
acs <- acs[, 1:10]
names(acs)
```

```{r}
tolower(names(acs))
```
```{r}
toupper(names(acs))
```

## Fixing character vectors
```{r}
splitnames = strsplit(names(acs), "\\_")
# this returns list

splitnames[[2]]
```
```{r}
splitnames = strsplit(names(acs), "\\.")
splitnames[[4]]
```

## QUICK aside - lists
```{r}
myList = list(letters = c("A", "B", "C"),
              numbers = 1:3,
              matrix(1:25, ncol = 5))

head(myList)
```

first element of the list
```{r}
myList[1]
```
```{r}
myList[[1]]
```
```{r}
myList$letters
```

```{r}
splitnames
```

## Sapply()
```{r}
splitnames[[4]][1]
```
APPLY to the each element of the LIST and take out fist element

split from the period
```{r}
firstelement <- function(x){x[1]}

sapply(splitnames, firstelement)
```

## SUB()
```{r}
names(acs)
```
```{r}
sub("\\_", "", names(acs))
```
```{r}
sub("\\.", "", names(acs))
```

## gsub()

Substitute ALL cases
```{r}
testname = "this_var_is_good"

sub("_", "", testname)
```
```{r}
gsub("_", "", testname)
```

## FINDING VALUES - grep(), grepl()
```{r}
filegdp = "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
download.file(url=filegdp, destfile = "data/gdp.csv")

gdp <- read_csv(file = "data/gdp.csv", col_types = cols(), skip = 4 )
```

## Find Location of matching values
```{r}
grep(pattern = "Arab", gdp$X4)
```
## return the matching values
```{r}
grep(pattern = "Arab", gdp$X4, value = TRUE)
```
```{r}
length(grep(pattern = "Arab", gdp$X4, value = TRUE))
```

## grepl()
logical vector
```{r}
table(grepl(pattern = "Arab", gdp$X4))
```

## filetering out not Arab countries
```{r}
gdp2 <- gdp[!grepl("Arab", gdp$X4), ]
```


```{r}
gdp3 <- 
    gdp %>%
    filter(!grepl("Arab", gdp$X4))
```

# Some More Useful String Functions
```{r}
library(stringr)

nchar("Davut Emrah AYAN")
```

```{r}
substr("Davut Emrah AYAN", 1, 5)
```
```{r}
paste("Davut", "Emrah", "AYAN", sep = " ")
```
# Zero spacing
```{r}
paste0("Davut","", "Emrah","", "AYAN")
```

```{r}
path = "data/deneme/"
filename = "deneme"

paste0(path,filename, ".csv")
```

```{r}
deneme = paste(gdp$X2, gdp$X4, sep = "_")
head(deneme)
```


# trim/strip extra space around values
```{r}
str_trim("   de  de  de    ")
```

### Regular Expressions

literals are exact word matches.

metacharcters are complex

```
^ : beginning of the line || ^i think 
$ : end of the line || morning$
[Aa][Yy][Aa][Nn] : ayan, Ayan, AYAN, ...
[a-z], [a-zA-Z] : range of letters

[^?.]$ : not ending with ? and .
```
## details
```
"." : means any characterb ||  A..n
|  : combining, serve as  "or"  ||  flood|fire|coldfire

^[Gg]ood|[Bb]ad   : begining with Good/good or anywhere Bad/bad 
^([Gg]ood|[Bb]ad) : similar to previous but all beginning of the line

? : optional
[Gg]eorge( [Ww]\.)? [Bb]ush : George W Bush, george bush
\. : dot here is a dot; not any character

* : repeat any number of times (even zero times)
+ : repeat at least one
(.*)  : repeat any character in paranthesis; (dfs), ()
[0-9]+ (.*)[0-9]+ : at least one number, followed by any number of character and at least one number again 

{ } : minimum and maximum number of matches

[Bb]ush( +[^ ]+ +){1,5} debate
     space-not space-space between 1 and 5 times
     
m,n : at least m but not more than n matches
m  : exactly m matches
m, : at least m matches
     
 +([a-zA-Z]+) +\1 : at least one space, at least one character  followed by one space, exact one replication of the exact phrase in the parenthesis  
 
* : is greedy, it matches the longest possible string 
^s(.*)s : starts with s, longest character in between s

? will make * less greedy
^s(.*?)s$
```









