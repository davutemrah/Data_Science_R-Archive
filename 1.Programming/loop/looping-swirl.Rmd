---
title: "R Notebook"
output:
  html_notebook: default
  html_document:
    df_print: paged
  word_document: default
  pdf_document: default
---

```{r}
library(swirl)
rm(list=ls())

flags <- read.csv("flags.csv")
```

# Loop functions
```{r}
head(flags, 3)
```
```{r}
# row and column numbers
dim(flags)
```
```{r}
class(flags)
```
## lapply

The lapply() function takes a list as input, applies a function to each element of the list, then returns a list of the same length as the original one. Since a data frame is really just a list of vectors (you can see this with as.list(flags)), we can use lapply() to apply the class() function to each column of the flags dataset. 
```{r}
# creates a list of class of each column
lapply(flags[, 1:3], class)
```

```{r}
cls_list <- lapply(flags, class)

class(cls_list)
```

lists are most helpful for storing multiple classes of data. cls_list can be simplified to a character vector.
```{r}
as.character(cls_list)
```

## sapply

sapply() allows you to automate this process by calling lapply() behind the scenes, but then attempting to simplify (hence the 's' in 'sapply') the result for you. Use sapply() the same way you used lapply() to get the class of each column of the flags dataset and store the result in cls_vect.
```{r}
# create a vector of class of each column, since class value of each column  has one value
sapply(flags, class)
```

```{r}
cls_vect <- sapply(flags, class)
class(cls_vect)
```

In general, if the result is a list where every element is of length one, then sapply() returns a vector. If the result is a list where every element is a vector of the same length (> 1), sapply() returns a matrix. If sapply() can't figure things out,then it just returns a list, no different from what lapply() would give you.

if we want to know the total number of countries (in our dataset) with, for example, the color orange on their flag, we can just add up all of the 1s and 0s in the 'orange' column
```{r}
sum(flags$orange)
```
Now we want to repeat this operation for each of the colors recorded in the dataset.
```{r}
#to extract the columns containing the color data and store them in a new data frame called flag_colors. 
flag_colors <- flags[, 11:17] 

# create a list of sum of each column
lapply(flag_colors, sum)
```

 to return a vector of column sums.
```{r}
# vector version of above action
sapply(flag_colors, sum)
```
```{r}
sapply(flag_colors, mean)
```
```{r}
flag_shapes <- flags[, 19:23]
```
Each of these columns (i.e. variables) represents the number of times a particular shape or design appears on a country's flag. We are interested in the minimum and maximum number of times each shape or design appears.

```{r}
# min-max value of each column in a list format
lapply(flag_shapes, range)
```
```{r}
# min-max value in column format
shape_mat <- sapply(flag_shapes, range)
shape_mat
```
```{r}
class(shape_mat)
```
```{r}
# demo of how to use unique function
unique(c(3, 4, 5, 5, 5, 6, 6))
```
```{r}
# list of unique values of each column in flags
unique_vals <- lapply(flags, unique)

# vector of number of unique values of each column in flags
sapply(unique_vals, length)
```

Occasionally, you may need to apply a function that is not yet defined, thus requiring you to write your own. Writing functions in R is beyond the scope of this lesson, but let's look at a quick example of how you might do so in the context of loop functions.

Pretend you are interested in only the second item from each element of the unique_vals list that you just created. Since each element of the unique_vals list is a vector and we're not aware of any built-in function in R that returns the second element of a vector, we will construct our own function.

```{r}
# So-called 'anonymous functions' can be very useful when one of R's built-in functions isn't an option.

# writing and applying a function to return second element of a column in unique_vals
lapply(unique_vals, function(elem) elem[2])
```
In the last lesson, you learned about the two most fundamental members of R's *apply family of functions: lapply() and sapply(). Both take a list as input, apply a function to each element of the list, then combine and return the result. lapply() always returns a list, whereas sapply() attempts to simplify the result.

the unique() function returns a vector of the unique values contained in the object passed to it. Therefore, sapply(flags, unique) returns a list containing one vector of unique values for each column of the flags dataset.

Whereas sapply() tries to 'guess' the correct format of the result, vapply() allows you to specify it explicitly. If the result doesn't match the format you specify, vapply() will throw an error, causing the operation to stop. This can prevent significant problems in your code that might be caused by getting unexpected return values from sapply().

Try vapply(flags, unique, numeric(1)), which says that you expect each element of the result to be a numeric vector of length 1. Since this is NOT actually the case, YOU WILL GET AN ERROR. Once you get the error, type ok() to continue to the next question.
```{r}
vapply(flags, unique, numeric(1))
```
```{r}
sapply(flags, class)
```

```{r}
vapply(flags, class, character(1))
```
You might think of vapply() as being 'safer' than sapply(), since it requires you to specify the format of the output in advance, instead of just allowing R to 'guess' what you wanted. In addition, vapply() may perform faster than sapply() for large datasets. However, when doing data analysis interactively (at the prompt), sapply() saves you some typing and will often be good enough.

As a data analyst, you'll often wish to split your data up into groups based on the
value of some variable, then apply a function to the members of each group. The next function we'll look at, tapply(), does exactly that.
```{r}
?tapply
```
The 'landmass' variable in our dataset takes on integer values between 1 and 6, each of which represents a different part of the world.
```{r}
table(flags$landmass)
```

Use table(flags$animate) to see how many flags contain an animate image.
```{r}
table(flags$animate)
```
 If you take the arithmetic mean of a bunch of 0s and 1s, you get the proportion of 1s. 
 
 Use tapply(flags$animate, flags$landmass, mean) to apply the mean function to the 'animate' variable separately for each of the six landmass groups, thus giving us the proportion of flags containing an animate image WITHIN each landmass group.
```{r}
tapply(flags$animate, flags$landmass, mean)
```
Similarly, we can look at a summary of population values (in round millions) for countries with and without the color red on their flag with tapply(flags$population, flags$red, summary).
```{r}
tapply(flags$population, flags$red, summary)
```
look at a summary of population values for each of the six landmasses.
```{r}
tapply(flags$population, flags$landmass, summary)
```
In this lesson, you learned how to use vapply() as a safer alternative to sapply(), which is most helpful when writing your own functions. You also learned how to use tapply() to split your data into groups based on the value of some variable, then apply a function to each group. These functions will come in handy on your quest to become a better data analyst.

## Quiz on Loops
```{r}
library(datasets)
data("iris")
?iris
```
There will be an object called 'iris' in your workspace. In this dataset, what is the mean of 'Sepal.Length' for the species virginica? 

```{r}
tapply(iris$'Sepal.Length', iris$Species, mean)
```
what R code returns a vector of the means of the variables 'Sepal.Length', 'Sepal.Width', 'Petal.Length', and 'Petal.Width'?
```{r}
apply(iris[,1:4], 2, mean)
```
```{r}
sapply(iris[, 1:4], mean)
```
```{r}
library(datasets)
data("mtcars")
?mtcars
```

```{r}
tapply(mtcars$mpg, mtcars$cyl, mean)
```
```{r}
sapply(split(mtcars$mpg, mtcars$cyl), mean)
```
```{r}
with(mtcars, tapply(mpg, cyl, mean))
```
```{r}
tapply(mtcars$hp, mtcars$cyl, mean)
```

```{r}
x <- 209.21429-82.63636
x
```













